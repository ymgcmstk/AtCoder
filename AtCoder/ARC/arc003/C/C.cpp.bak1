// This template is based on http://ctylim.hatenablog.com/entry/2015/08/30/191553, provided by ctylim.
#include <iostream>
#include <iomanip>
#include <vector>
#include <set>
#include <map>
#include <algorithm>
#include <numeric>
#include <functional>
#include <cmath>
#include <queue>
#include <stack>
#include <utility>

#define repd(i,a,b) for (int i=(a);i<(b);i++)
#define mrepd(i,a,b) for (int i=(b-1);i>=(a);i--)
#define rep(i,n) repd(i,0,n)
#define mrep(i,n) mrepd(i,0,n)
#define LL long long
#define MOD 1000000007
using namespace std;

template <typename T>
void show_array(T arr[]) {
  rep(i, sizeof(*arr)/sizeof(arr[0])) cout << arr[i] << ' ';
  cout << endl;
}


template <typename T>
void show_vec(vector<T> vec) {
  rep(i, vec.size()) cout << vec[i] << ' ';
  cout << endl;
}

bool debug_mode = false;

typedef pair<int, double> pid;

class Path {
public:
  int time, x, y;
  double brightness;
  Path() {}
  Path(int t, double b) : time(t), brightness(b) {}
  Path(int t, double b, int _x, int _y) : time(t), brightness(b), x(_x), y(_y) {}
  int get_time() {
    return time;
  }
  double get_br() {
    return brightness;
  }
  void print() {
    cout << "x: " << x << ", y: " << y << ", time: " << time << ", brightness: " << brightness << endl;
  }
};

struct PairComparator {
  bool operator()(Path& p1, Path& p2) const
  {
    if( p1.time  < p2.time ) return true;
    if( p1.time  > p2.time ) return false;
    if( p1.brightness < p2.brightness ) return false;
    if( p1.brightness > p2.brightness ) return true;
    return true;
  }
};

typedef priority_queue<Path, vector<Path>, PairComparator> PQ_Path;

vector<double> t_0d9;

void push_to_PQ(Path *cur_path, vector<vector<double> >& map_max, PQ_Path& PQ, vector<vector<int> >& map_br) {
  int t, cur_i, cur_j;
  double br;
  double cur;
  if (debug_mode) cur_path->print();
  br = cur_path->brightness;
  t = cur_path->time;
  cur_i = cur_path->x;
  cur_j = cur_path->y;
  if (map_max[cur_i][cur_j] > br) {
    return;
  }
  map_max[cur_i][cur_j] = br;
  while (t_0d9.size() <= t + 1) t_0d9.push_back(t_0d9[t_0d9.size()-1] * 0.99);
  if (cur_i > 0) {
    cur = min(br, t_0d9[t+1] * map_br[cur_i-1][cur_j]);
    if (cur > map_max[cur_i-1][cur_j]) PQ.push(Path(t+1, cur, cur_i-1, cur_j));
  }
  if (cur_j > 0) {
    cur = min(br, t_0d9[t+1] * map_br[cur_i][cur_j-1]);
    if (cur > map_max[cur_i][cur_j-1]) PQ.push(Path(t+1, cur, cur_i, cur_j-1));
    // PQ.push(Path(t+1, min(br, t_0d9[t+1] * map_max[cur_i][cur_j-1]), cur_i, cur_j-1));
  }
  if (cur_i < map_max.size()-1) {
    cur = min(br, t_0d9[t+1] * map_br[cur_i+1][cur_j]);
    if (cur > map_max[cur_i+1][cur_j]) PQ.push(Path(t+1, cur, cur_i+1, cur_j));
    // PQ.push(Path(t+1, min(br, t_0d9[t+1] * map_max[cur_i+1][cur_j]), cur_i+1, cur_j));
  }
  if (cur_j < map_max[0].size()-1) {
    cur = min(br, t_0d9[t+1] * map_br[cur_i][cur_j+1]);
    if (cur > map_max[cur_i][cur_j+1]) PQ.push(Path(t+1, cur, cur_i, cur_j+1));
    // PQ.push(Path(t+1, min(br, t_0d9[t+1] * map_max[cur_i][cur_j+1]), cur_i, cur_j+1));
  }
}

void print_mapd(vector<vector<double> > map1) {
  rep(i, map1.size()) {
    rep(j, map1[0].size()) cout << map1[i][j];
    cout << endl;
  }
}

void print_mapi(vector<vector<int> > map1) {
  rep(i, map1.size()) {
    rep(j, map1[0].size()) cout << map1[i][j];
    cout << endl;
  }
}

int main() {
  int N, M;
  cin >> N >> M;
  vector<vector<double> > map_max(N);
  vector<vector<int> > map_br(N);
  rep(i, N) {
    map_max[i] = vector<double>(M);
    fill(map_max[i].begin(), map_max[i].end(), -1);
    map_br[i] = vector<int>(M);
  }
  PQ_Path PQ;
  int s_i, s_j;
  int g_i, g_j;
  string::size_type s_index;
  rep(i, N) {
    string temp_str;
    cin >> temp_str;
    rep(j, M) {
      if (temp_str[j] == 's') {
        map_br[i][j] = 10;
        s_i = i;
        s_j = j;
        map_max[i][j] = 10.0;
      } else if (temp_str[j] == 'g') {
        map_br[i][j] = 10;
        g_i = i;
        g_j = j;
      } else if (temp_str[j] == '#') map_br[i][j] = -1;
      else map_br[i][j] = int(temp_str[j] - '0');
    }
  }
  if (debug_mode) {
    print_mapd(map_max);
    print_mapi(map_br);
    cout << s_i << ' ' << s_j << endl;
  }
  t_0d9.push_back(1);

  push_to_PQ(new Path(0, 10, s_i, s_j), map_max, PQ, map_br);
  Path cur_pid;
  while (PQ.size() > 0) {
    cur_pid = PQ.top(); PQ.pop();
    push_to_PQ(&cur_pid, map_max, PQ, map_br);
  }
  if (map_max[g_i][g_j] < 0) {
    cout << -1 << endl;
  } else {
    cout << setprecision(15) << map_max[g_i][g_j] << endl;
  }
  return 0;
}
